# Exploit 500

We are given an executable that listens on port 4919

```
./task7
```
and
```
nc localhost 4919
Hello, in order to get a flag thou must guess a number. Thou have 3 tries. Generating number... Your guess?
1
Wrong number, it was 1289088234

Generating number... Your guess?
2
Wrong number, it was 1973061390

Generating number... Your guess?
3
Wrong number, it was 289888385

Thank you for your time, sir!
```

let's see what the program looks like, I'll use Radare2 for this one.

```
r2 task7
[0x08048680]> aa
[0x08048680]> s sym.main
[0x08048b6f]> pdf
[0x08048b6f]> s sym.handle_client
[0x08048b0e]> pdf
...
0x08048b4e    890424         mov dword [esp], eax
0x08048b51    e8e6fdffff     call sym.play_guess_game
^- sym.play_guess_game()
...
```

debugging symbols are on, which is nice. Here I went into the handle_client function and printed it,
the play_guess_game function is probably what we want. I left out some of the function, but the important bits are up there

```
0x08048b0e]> s sym.play_guess_game
[0x0804893c]> pdf
0x08048977    e854fcffff     call sym.imp.write
...
0x0804897c    c74424040000.  mov dword [esp + 4], 0
0x08048984    8b4508         mov eax, dword [ebp+arg_2]    ; [$x8:4]=0
0x08048987    890424         mov dword [esp], eax
0x0804898a    e856feffff     call sym.try_guess
0x0804898f    83e00f         and eax, 0xf
0x08048992    83c001         add eax, 1
0x08048995    a380a00408     mov dword [obj.first_try], eax
0x0804899a    c74424040100.  mov dword [esp + 4], 1
0x080489a2    8b4508         mov eax, dword [ebp+arg_2]    ; [$x8:4]=0
0x080489a5    890424         mov dword [esp], eax
0x080489a8    e838feffff     call sym.try_guess
0x080489ad    a384a00408     mov dword [obj.second_try], eax
0x080489b2    c74424040200.  mov dword [esp + 4], 2
0x080489ba    8b4508         mov eax, dword [ebp+arg_2]    ; [0x8:4]=0
0x080489bd    890424         mov dword [esp], eax
0x080489c0    e820feffff     call sym.try_guess
...
0x080489cd    e8defbffff     call sym.imp.strlen
0x080489e6    e8e5fbffff     call sym.imp.write
```

I left out some stuff again, but it just calls the try_guess function three times, passing the try number as a
parameter and storing the results of the first two into variables first_try and second_try. The it prints
the farewell message. Let's see this try_guess:

```
[0x0804893c]> s sym.try_guess
[0x080487e5]> pdf
...
0x8048844    e8e7fcffff     call sym.imp.read
...
0x08048862    e8f9fdffff     call sym.imp.strtol
0x08048867    8945f4         mov dword [ebp-input_long], eax
0x0804886a    8b450c         mov eax, dword [ebp+arg_3]    ; [0xc:4]=0
0x0804886d    890424         mov dword [esp], eax
0x08048870    e819ffffff     call sym.next_rand
0x08048875    a38ca00408     mov dword [obj.always_random_number], eax
0x0804887a    a18ca00408     mov eax, dword [obj.always_random_number]
0x0804887f    3945f4         cmp dword [ebp-input_long], eax  ; [0x13:4]=256
...
0x08048924    8b45f4         mov eax, dword [ebp-input]
0x08048927    8d5001         lea edx, dword [eax + 1]
0x0804892a    a18ca00408     mov eax, dword [obj.always_random_number]
0x0804892f    0fafc2         imul eax, edx
```
this one just scans for you input, converts it to a long, and compares it to the output of
next_rand. If you guess it right, it will print out the flag, otherwise it multiplies your input
and the random number and returns it (this is stored in first/second_try

one thing suspicious is that it passes the try number (arg_3) to next_rand. Maybe next_rand isn't
completely random...

```
[0x080487e5]> s sym.next_rand
[0x0804878e]> VV

                        =-------------------------=
                        | [0x804878e]             |
                        | push ebp                |
                        | mov ebp, esp            |
                        | sub esp, 0x28           |
                        | cmp dword [ebp + 8], 2  |
                        | jne 0x80487de           |
                        =-------------------------=
                              t f
              .---------------' '-----------------.
              |                                   |
              |                                   |
        =-------------------=             =--------------------------=
        |  0x80487de        |             |  0x804879a               |
        | call sym.imp.rand |             | mov dword [ebp - 0xc], 0 |
        =-------------------=             | jmp 0x80487cd            |
            v                             =--------------------------=
            |                                 v
            '-----.                        .--'
                  |                        |
                  |                        |
                  |                    =--------------------------------=
                  |                    |  0x80487cd                     |
                  |                    | mov eax, dword [obj.first_try] |
                  |                    | cmp dword [ebp - 0xc], eax     |
                  |                    | jb 0x80487a3                   |
                  |                    =--------------------------------=
                  |                        | t f
                  |           .------------|-' '--------------------------.
                  |           |            |                              |
                  |           |            |                              |
                  |     =-----------------------------------=     =----------------------------------=
                  |     |  0x80487a3                        |     |  0x80487d7                       |
                  |     | mov eax, dword [ebp - 0xc]        |     | mov eax, dword [obj.unguessable] |
                  |     | add eax, 1                        |     | jmp 0x80487e3                    |
                  |     | mov edx, eax                      |     =----------------------------------=
                  |     | mov eax, dword [obj.second_try]   |         v
                  |     | mov dword [esp + 4], edx          |         |
                  |     | mov dword [esp], eax              |         |
                  |     | call sym.rot                      |         |
                  |     | mov edx, dword [obj.unguessable]  |         |
                  |     | xor eax, edx                      |         |
                  |     | mov dword [obj.unguessable], eax--|---------'
                  |     | add dword [ebp - 0xc], 1          |
                  |     =-----------------------------------=
                  |         `--------------'  |
                  '---------------------------|
                                              |
                                              |
                                          =----------------=
                                          |  0x80487e3     |
                                          | leave          |
                                          | ret            |
                                          =----------------=


```

There's radare's pretty graph view for that function. ebp + 8 there is the try number. So the first two
tries the number is actually completely random, from rand. but then it does it's own random number generation
based on the two previous random numbers and your inputs. (first_try and second_try)
so... not random at all.

From here you could write a script that mimic the random number generation and plug in your inputs and the results
you get from the server. That's a little complicated though as there are a few small pieces you have to catch, such
as the addition of 1 before returning from try_guess and the addition and anding after the first try_guess. So I just
ran this through gdb while I also connected to the server and changed the values returned from rand to be the values
the server generated, because they were nice and printed those out for us :D

to do this in gdb just
```
set follow-for-mode child
break rand
```

then connect to the local process and to the server, and give them the same first guess. gdb will hit the breakpoint
and the server will return the randomly generated number. In gdb:
```
ni
set $eax=number_from_server
continue
```

send both another guess, and repeate gdb commands with the second random number. Then give gdb a third random guess
and continue. The guess was wrong, but it told us what the correct number was, and because it was entirely dependent
on our input and random numbers that we know, that is the correct number for the game!

and we have the flag
```
Hello, in order to get a flag thou must guess a number. Thou have 3 tries.
Generating number... Your guess?
5
Wrong number, it was 2035012844

Generating number... Your guess?
5
Wrong number, it was 363000463

Generating number... Your guess?
3832595076
Welp, can't argue with that. Here's your flag{y0uD4B35tnuMb3Rgenerator3veR!!1}
```
